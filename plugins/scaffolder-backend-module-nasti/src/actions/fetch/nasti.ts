/*
 * Copyright 2021 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  ContainerRunner,
  UrlReader,
  resolveSafeChildPath,
} from '@backstage/backend-common';
import { JsonObject, JsonValue } from '@backstage/types';
import { InputError } from '@backstage/errors';
import { ScmIntegrations } from '@backstage/integration';
import commandExists from 'command-exists';
import fs from 'fs-extra';
import path, { resolve as resolvePath } from 'path';
import { Writable } from 'stream';
import {
  createTemplateAction,
  fetchContents,
  executeShellCommand,
} from '@backstage/plugin-scaffolder-node';

export class NastiRunner {
  private readonly containerRunner?: ContainerRunner;

  constructor({ containerRunner }: { containerRunner?: ContainerRunner }) {
    this.containerRunner = containerRunner;
  }

  private async fetchTemplateNasti(
    directory: string,
  ): Promise<Record<string, JsonValue>> {
    try {
      return await fs.readJSON(path.join(directory, 'nasti.json'));
    } catch (ex) {
      if (ex.code !== 'ENOENT') {
        throw ex;
      }

      return {};
    }
  }

  public async run({
    workspacePath,
    values,
    logStream,
    imageName,
    templateDir,
    templateContentsDir,
  }: {
    workspacePath: string;
    values: JsonObject;
    logStream: Writable;
    imageName?: string;
    templateDir: string;
    templateContentsDir: string;
  }): Promise<void> {
    const intermediateDir = path.join(workspacePath, 'intermediate');
    await fs.ensureDir(intermediateDir);
    const resultDir = path.join(workspacePath, 'result');

    // First lets grab the default nasti.json file
    const nastiJson = await this.fetchTemplateNasti(templateContentsDir);

    const nastiInfo = {
      ...nastiJson,
      ...values,
    };

    const nastiJsonPath = path.join(templateDir, 'nasti.json');
    await fs.writeJSON(nastiJsonPath, nastiInfo);

    // Directories to bind on container
    const mountDirs = {
      [templateDir]: '/input',
      [intermediateDir]: '/output',
    };

    // the command-exists package returns `true` or throws an error
    const nastiInstalled = await commandExists('nasti').catch(() => false);
    if (nastiInstalled) {
      await executeShellCommand({
        command: 'nasti',
        args: ['process', '-f', nastiJsonPath, intermediateDir],
        logStream,
      });
    } else {
      if (this.containerRunner === undefined) {
        throw new Error(
          'Invalid state: containerRunner cannot be undefined when nasti is not installed',
        );
      }
      await this.containerRunner.runContainer({
        imageName: imageName ?? 'quay.io/rh_ee_addrew/nasti:master',
        command: 'nasti',
        args: ['process', '-f', nastiJsonPath, intermediateDir],
        mountDirs,
        workingDir: '/input',
        // Set the home directory inside the container as something that applications can
        // write to, otherwise they will just fail trying to write to /
        envVars: { HOME: '/tmp' },
        logStream,
      });
    }

    // if nasti was successful, intermediateDir will contain
    // exactly one directory.

    const [generated] = await fs.readdir(intermediateDir);

    if (generated === undefined) {
      throw new Error('No data generated by nasti');
    }

    await fs.move(path.join(intermediateDir, generated), resultDir);
  }
}

/**
 * Creates a `fetch:nasti` Scaffolder action.
 *
 * @remarks
 *
 * See {@link https://github.com/adamrdrew/nasti} and {@link https://backstage.io/docs/features/software-templates/writing-custom-actions}.
 * @param options - Templating configuration.
 * @public
 */
export function createFetchNastiAction(options: {
  reader: UrlReader;
  integrations: ScmIntegrations;
  containerRunner?: ContainerRunner;
}) {
  const { reader, containerRunner, integrations } = options;

  return createTemplateAction<{
    url: string;
    targetPath?: string;
    values: JsonObject;
    copyWithoutRender?: string[];
    extensions?: string[];
    imageName?: string;
  }>({
    id: 'fetch:nasti',
    description:
      'Downloads a template from the given URL into the workspace, and runs nasti on it.',
    schema: {
      input: {
        type: 'object',
        required: ['url'],
        properties: {
          url: {
            title: 'Fetch URL',
            description:
              'Relative path or absolute URL pointing to the directory tree to fetch',
            type: 'string',
          },
          targetPath: {
            title: 'Target Path',
            description:
              'Target path within the working directory to download the contents to.',
            type: 'string',
          },
          values: {
            title: 'Template Values',
            description: 'Values to pass on to nasti for templating',
            type: 'object',
          },
          copyWithoutRender: {
            title: 'Copy Without Render',
            description:
              'Avoid rendering directories and files in the template',
            type: 'array',
            items: {
              type: 'string',
            },
          },
          extensions: {
            title: 'Template Extensions',
            description:
              "Jinja2 extensions to add filters, tests, globals or extend the parser. Extensions must be installed in the container or on the host where nasti executes. See the contrib directory in Backstage's repo for more information",
            type: 'array',
            items: {
              type: 'string',
            },
          },
          imageName: {
            title: 'Nasti Docker image',
            description:
              "Specify a custom Docker image to run nasti, to override the default: 'quay.io/rh_ee_addrew/nasti:master'. Used only when a local nasti is not found.",
            type: 'string',
          },
        },
      },
    },
    async handler(ctx) {
      ctx.logger.info('Fetching and then templating using nasti');
      const workDir = await ctx.createTemporaryDirectory();
      const templateDir = resolvePath(workDir, 'template');
      const templateContentsDir = resolvePath(
        templateDir,
        "{{nasti and 'contents'}}",
      );
      const resultDir = resolvePath(workDir, 'result');

      if (
        ctx.input.copyWithoutRender &&
        !Array.isArray(ctx.input.copyWithoutRender)
      ) {
        throw new InputError(
          'Fetch action input copyWithoutRender must be an Array',
        );
      }
      if (ctx.input.extensions && !Array.isArray(ctx.input.extensions)) {
        throw new InputError('Fetch action input extensions must be an Array');
      }

      await fetchContents({
        reader,
        integrations,
        baseUrl: ctx.templateInfo?.baseUrl,
        fetchUrl: ctx.input.url,
        outputPath: templateContentsDir,
      });

      const nasti = new NastiRunner({ containerRunner });
      const values = {
        ...ctx.input.values,
        _copy_without_render: ctx.input.copyWithoutRender,
        _extensions: ctx.input.extensions,
      };

      // Will execute the template in ./template and put the result in ./result
      await nasti.run({
        workspacePath: workDir,
        logStream: ctx.logStream,
        values: values,
        imageName: ctx.input.imageName,
        templateDir: templateDir,
        templateContentsDir: templateContentsDir,
      });

      // Finally move the template result into the task workspace
      const targetPath = ctx.input.targetPath ?? './';
      const outputPath = resolveSafeChildPath(ctx.workspacePath, targetPath);
      await fs.copy(resultDir, outputPath);
    },
  });
}
